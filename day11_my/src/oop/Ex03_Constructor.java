package oop;

class Product {
	// 필드 (상품의 이름과 가격을 기재한다.)
	String name;
	int price;
	
	// 생성자 
	Product(){
		System.out.println("비어있는 Product객체 하나 생성");
	}
	// 생성자는 함수이므로, 오버로딩이 가능하다.
	// 함수이름이 같아도, 매개변수 타입이 다르거나 순서가 다르다면 여러개 정의할 수 있다.
	Product(String name, int price){
		// 하나의 클래스로 여러 객체를 생성할 때, 현재 작업중인 객체 자기 자신을 가리키기 위해
		// this라는 키워드를 사용한다.
		this.name = name;		// 전달받은 이름을 멤버 필드 name에 저장한다.
		this.price = price;		// 전달받은 가격을 멤버 필드 price에 저장한다.
		System.out.println("데이터를 전달받아서  Product 객체하나 생성");
	}
	
	// 메서드 (상품 정보를 간략히 출려가는 기능)
	void show() {
		System.out.printf("%s : %,d원\n",name, price);
	}
}

public class Ex03_Constructor {
	public static void main(String[] args) {
		// 생성자는 클래스를 이용하여 객체를 생성할 때 호출하는 특수한 함수이다.
		
		// 자바에서는 오로지, 생성자를 통한 객체 생성만 가능하다.
		// 예외적으로 함수형 인터페이스의 람다식 객체 생성이 있으나 방식이 다소 다르다.
		// 참조 변수를 여러개 만들었다고 하더라고, 생성자를 호출하지 않았다면 객체가 없는 것이다.
		
		// 생성자의 이름은 클래스의 이름과 동일한다.
		// 생성자는 함수이지만, 반환형을 지정하지 않는다.
		// 생성자는 함수이므로, 오버로딩이 가능하다.
		
		// 생성자의 주 목적은 객체를 생성하는 것이고
		// 또다른 목적은 객체 새성시 초기작동을 추가하는 것이다.
		
		Product p1 = new Product(); // 비어있는 객체 생성
		p1.name = "아메리카노";		// 값을 전달하지 않고 생성했으니
		p1.price = 2000;			// 멤버 필드에 직접 값을 대입해야 한다.
		p1.show();
		
		// 초기값을 전달하여 객체를 생성했기 때문에, 대입 과정을 생략할 수 있다.
		Product p2 = new Product("돌체라떼", 4000); 
		p2.show();
		
		// 자바는 생성자를 호출하지 않으면 객체를 생성하지 않는다.
//		Product p3 = null;
//		Product p4;
//		p3.show();	// 객체가 없어서 실행이 안됨
//		p4.show();	// 객체가 없어서 실행이 안됨
		
		// 클래스를 작성할때, 생성자를 아예 손대지 않으면(만들지 않으면)
		// 컴파일 시에 클래스에 기본 생성자 코드를 추가해 준다.
		// 하나라도 생성자가 있으면 기본 생성자가 자동으로 생기지 않는다.
		// 기본 생성자 : 매개변수를 전달받지 않는 생성자
	}
}
